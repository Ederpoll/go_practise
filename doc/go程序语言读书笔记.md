# 读书笔记

## 第二章 程序结构：

### 变量

短变量声明  := 是用来声明和初始化局部变量的；

短变量声明最少声明一个新变量，否则，代码无法通过编译；

指针别名允许我们不用变量的名字来方文变量；不仅仅指针产生别名，当复制其他引用类型(像slice，map，channel，甚至包括这里引用类型的结构体、数组和接口)的值的时候，也会产生别名

### new函数

new函数是一个内置的函数，表达式 ***new(T)*** 创建一个未命名的T类型变量，初始化为T类型的零值，并**返回其地址**；

一般情况下，每次调用new都返回一个具有唯一地址的不同变量，除了一个例外：**两个变量的类型不携带任何信息且是零值，例如struct{} 和 [0]int, 当前的实现里面，他们具有相同的地址**

**new是一个预声明的函数，不是一个关键字**

### 变量的生命周期

- 包级别变量的生命周期是整个程序的执行时间

某个函数内的局部变量，如果被全局变量引用了，那么它一定使用了堆变量，即使函数返回了，这个变量还是可以被访问到，这种情况我们称为变量从函数中 **逃逸**；每次变量逃逸都需要一次额外的内存分配，因此在做性能优化时，是有好处的；

## 第三章 基本数据

### 整数

rune类型是 int32类型的同义词，常常用来指明一个值是unicode码点，这两个类型可以互换使用

取模运算符 % 只能用于整数，在go语言中，取模余数的符号只与除数一致，-5%2 和 -5%-2的结果都是-3

除法的行为则与运算中是否都为整数相关，如

```go
y1 := 5/4    //y1=1
y2 := 5.0/4  //y2=1.25
y3 := 5/4.0  // 1.25
y4 := 5.0/4/0 // 1.25
```

- 一元加法和一元减法

+x 表示一元取正

-x 表示一元取负

- &^位清空操作

c = a &^ b
含义：b 转为二进制时，值为1 的位置对应c的位置值为0；c中剩余位置值与a对应位置值相同（即：所谓的位清空操作，把b中1对应位置在c位置上清空）

```go
a := 12  // 00001100
b := 4   // 00000100
c := a &^ b  //00001000
fmt.Println(c) // 8
```

### 复数

```go
var x complex128 = complex(3, 4) // 3 + 4i
```

### 字符串

字符串可以和字节byte相互转化

```go
var s
= "vbadd"
b := []byte(s)
c := string(b)
```

[]byte(s) 操作会分配新的字节数组，拷贝填入s含有的字节，并生成一个slice引用，指向整个数组， 反之，用string()将byte转换成字符串也会产生一份副本

bytes包为了高效处理字节slice提供了Buffer类型；Buffer起初为空，其大小随着各种类型数据的写入而增长，bytes.Buffer 变量无须初始化，原因是零值本来就有效

#### 字符串和数字的相互转换

要将整数转换成字符串，一种选择是 **fmt.Sprintf** 另一种选择是 **strconv.Itoa**

```go
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // "123 123"
```



### 常量

常量修饰符 const 可以声明多个常量

- 常量生成器iota

iota创建一系列相关值，而不是逐个值显式写出，常量声明中，iota从0开始取值，逐项加1。这种写法 **常用来声明枚举**

iota 也可用于复杂的表达式

```go
type Flags int

const (
	FlagUp Flags = 1 << iota
	FlagDown
	FlagBroadcast
)

const (
	_   = 1 << (10 * iota)
	KiB // 1024
	MiB
	GiB
	TiB
	PiB
	EiB
	ZiB
	YiB
)

func main() {
	fmt.Println(FlagUp)
	fmt.Println(FlagDown)
	fmt.Println(FlagBroadcast)
  fmt.Println(GiB)
}
```

## 第四章 复合数据类型

### 数组

在数组字面量上，如果省略号... 出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定；

数组，slice，map 和结构体的字面语法都是相似的。可以按照 索引: 索引对应的值 这种方式进行数组定义:

```go
const (
 USD int = iota
 EUR
 GBP
)

symbol := [...]string {USD:"$", EUR:"€", GBP:"£"}

r := [...]int{99: -1} // 定义了一个有100个元素的数组r，除了最后一个元素值是-1之外，该数组中的其他元素值都是0
```

调用函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数；

使用这种方式传递大的数组会变得很低效，**go把数组和其他类型都看成值传递，而在其他的一些语言中，数组是隐式使用引用传递。**

### slice

slice表示一个拥有相同类型元素的可变长度的序列，slice和数组是紧密相连的，slice底层实现是个数组，称之为底层数组；slice有三个属性：***指针、长度、容量***

slice操作符s[i:j] 创建了一个新的slice，这个新slice引用了序列s从i到j-1索引位置的所有元素

因为slice包含了指向数组元素的指针，所以将一个slice传递给函数的时候，可以在函数内部修改底层数组的元素

```go
func reverse(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

func main() {
	a := [...]int{0, 1, 2, 3, 4, 5}
	reverse(a[:])
	fmt.Println(a)
}
```

和数组不同的是，slice无法做比较，因此不能用== 来测试两个slice是否拥有相同的元素，标准库只提供了字节slice的比较函数 bytes.Equal, 其他类型的比较需要我们自己写函数；

slice唯一允许的比较操作是和nil做比较；

- 创建一个数组的slice 等于为数组创建了一个别名， 例如，a int[10] 的别名为 a[:]

内置函数 make可以创建一个具有指定元素类型，长度和容量的slice

```go
a := make([]T, len)
b := make([]T, len, cap)
```

slice可以用来实现栈

```go
stack = append(stack, v) //入栈
top := stack[len(stack) -1]
stack = stack[: len(stack) -1] // 出栈

```

### map

go语言中，map是哈希表的引用，map的类型是map[K]V 其中，键的类型必须是可以通过操作符 == 来进行比较的数据类型，所以map 可以检测一个键值是否已经存在

可以使用内置函数delete 从字典中根据键值移除一个元素

```go
ages := map[string]int {
  "alice": 30,
  "beyond":34
}
delete(ages, "alice")
```

- 注意，map使用给定的键来查找元素， 如果对应的元素不在，就返回值类型的零值，在下面的代码中：

```go
age["bob"] = age["bob"] + 1 // = 1
```

- map元素不是一个变量，不可以获取它的地址

```go
_ = &age["bob"] // 编译错误
```

go语言这么做的一个原因是为了保护数据，防止已有元素被重新散列到新的位置，这样就可能使得获取的地址无效

map类型的零值是nil，也就是说，没有引用任何散列表；

大多数map的操作都可以安全地在map的零值nil上执行，除了设置元素， **这要求我们必须首先初始化map**

```go
var ages map[string]int // nil
fmt.Println(ages == nil) // true
ages["carl"] = 6 // panic!!!
```

### struct

- 如果一个结构体成员变量名称是首字母大写的，那么这个变量是可以导出的，这个是GO最主要的访问控制机制；一个结构体可以同时包含可导出和不可导出的成员变量(访问控制)

- 结构体字面量

结构体类型的值可以通过该结构体字面量来设置，有两种形式：

```go
type Point struct {
	X, Y int
}

p  := Point{1, 2} // 顺序不能变
p1 := Point{
	Y: 2,
	X: 1,
}
```
- 如果结构体中的所有成员变量都可以比较，那么这个结构体就是可以比较的

- 结构体嵌套支持了 “匿名成员”

如果匿名成员本身是可以支持导出的，那么即便他们所在的上级结构体不可以导出，匿名成员也是可以隐式导出的，相比之下，如果一级一级使用成员变量，则不可以导出

在打印的时候，副词 # 支持让格式化符号以类型GO语法的方式输出对象，例如 fmt.Printf("%#v\n", p1)  -> Point{X:1, Y:2}

### JSON

JSON 是 JavaScript 值的 Unicode 编码；Go通过标准库 encoding/json 和其他的一些库对 json格式的编码解码提供了非常好的支持；

JSON的对象是一个从字符串到值的映射，写成name:value 对的序列，每个元素之间用逗号分隔，两边用花括号括起来；

把 Go的数据结构转换成 JSON 称为 marshal，对应的， 将JSON转换成go的数据结构为unmarshal

marshal生成了一个字节slice，其中包含了一个不带任何多余空白字符的很长的字符串，为了方便阅读，json.MarshalIndent 的变体可以输出整齐格式化过的结果，该函数的两个参数，一个是定义每行输出的前缀字符串，另外一个是缩进字符串；

- 成员标签

成员标签指定了字段在json中的字段

```go
type Date struct {
	Year  int `json: "year"`
	Month int `json: "month"`
}
```

### 文本和HTML模板

模板是一个字符串或者文件，它包含一个或者多个两边用双大括号包围的单元--- {{...}}, 这称为操作。大多数的字符串是直接输出的，但是操作可以引发其他的行为。每个操作在模板语言里面都对应一个表达式，提供的简单但强大的功能包括：输出值，选择机构体成员，调用函数和方法，描述控制逻辑，实例化其他模板等；

## 函数


